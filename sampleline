~make_sampleline_param = { arg name, default_value=[];
	var ret;
	ret = (
		name: name,
		classtype: \sampleline,
		selected_cell: 0,
		selected: 0,
		default_val: default_value.asList,
		notes: ~default_sampleline.deepCopy,
		start_offset: 0,
		end_offset: 0,
		muted: false,
		archive_data: [\name, \classtype, \selected, \selected_cell, \default_val, \notes, \start_offset, \end_offset, \notequant],
		notequant: nil,
		vnotes: [],

		save_data: { arg self;
			var data = ();
			self.archive_data.do {
				arg key;
				data[key] = self[key];
			};
			[\seq].do { arg kind;
				data[kind] = ();
				[\val].do { arg key;
					data[kind][key] = self[kind][key];
				}
			};
			data;
		},

		load_data: { arg self, data;
			self.archive_data.do {
				arg key;
				self[key] = data[key];
			};
			[\seq].do { arg kind;
				[\val].do { arg key;
					 self[kind][key] = data[kind][key];
				}
			};
		},

		seq: (
			val: default_value.asList,
			change: { arg self, fun;
				self.val = fun.(self.val);
			}
		),
		get_cells: { arg self;
			self.seq.val;
		},
		get_selected_cell: { arg self;
			self.selected_cell;
		},
		select_param: { arg self;
			self.selected = 1;
			self.changed(\selected);
		},
		deselect_param: { arg self;
			self.selected = 0;
			self.changed(\selected);
		},

		add_cells: { arg self, cells;
			self.seq.val.addAll(cells);
			self.changed(\cells);
		},

		remove_cells: { arg self, num;
			self.seq.val = self.seq.val[.. (self.seq.val.size - num - 1) ];
			self.changed(\cells);
		},

		set_val: { arg self, val;
			self.seq.val[ self.get_selected_cell.() ] = if(val > 1, { 1 },{ 0 });
		},

		get_notes: { arg self;
			var no;
			no = self.vnotes.deepCopy;
			//no[0].dur+self.start_offset;
			//no.last.dur+self.end_offset;
			no.debug("£££££££££££££££££££££££££££££sampleline param: get_notes");
			no;
		},

		set_notes: { arg self, val;
			self.notes = val;
			val.debug("£££££££££££££££££££££££££££££sampleline param: set_notes");
			self.update_note_dur;
		},

		trans_notes: { arg self;
			// make sample slots compatibles with other code using midinotes
			self.notes = self.notes.collect { arg x;
				x.midinote = x.slotnum;
			};
		},

		get_note: { arg self, idx;
			var no, res;
			[idx, self.vnotes].debug("sampleline param: get_note");
			res = if( self.vnotes.size > 0 && {self.muted.not}) {
				no = self.vnotes[idx].deepCopy;
				if( no.notNil && (self.notequant.notNil) ) {
					no.dur = no.dur.round(self.notequant);
					"1".debug;
					no;
				} {
					"2".debug;
					no
				}
			} {
				"sampleline_param: get_node: No notes".inform;
				if(idx == 0) {
					"3".debug;
					~empty_note;
				} {
					"4".debug;
					nil;
				};
			};
			res.debug("sampleline param: get_note: res");
		},

		total_dur: { arg self, notes;
			var res=0;
			notes.do { arg x; res = x.dur + res; };
			res;
		},

		update_note_dur: { arg self;
			var find_next, find_prev, delta, prevdelta, idx, previdx;
			"update_note_dur".debug("start");
			self.trans_notes;

			if( self.notes.size > 2) {
				find_next = { arg dur, notes;
					var res=0, vidx=0, last=nil, delta=0, prevdelta=0;
					dur.debug("find_next: dur");
					if(dur == 0) {
						delta = 0;
						vidx = 0
					} {
						notes[1..].do { arg x, n;
							[n, res, vidx, last, dur].debug("begin n res vidx last");
							if( res < dur ) {
								res = x.dur + res;
								vidx = vidx + 1;
								last = x.dur;
							};
							[n, res, vidx, last].debug("end");
						};
						delta = res - dur;
					};
					[ delta, vidx+1 ];
				};

				find_prev = { arg dur, notes;
					var res=0, vidx=0, last=nil, delta=0, prevdelta=0;
					dur = self.total_dur( notes[1..(notes.lastIndex-1)] ).debug("total dur") - dur;
					dur.debug("find_prev: dur");

					notes[1..].do { arg x, n;
						[n, res, vidx, last].debug("begin n res vidx last");
						if( res <= dur ) {
							res = x.dur + res;
							vidx = vidx + 1;
							last = x.dur;
						};
						[n, res, vidx, last].debug("end");
					};
					delta = res - dur;
					if(last.isNil) {
						prevdelta = nil
					} {
						last.debug("last");
						prevdelta = last - delta;
					};
					[ prevdelta, vidx ];
				};

				#delta, idx = find_next.(self.notes[0].start_offset, self.notes);
				#prevdelta, previdx = find_prev.(self.notes[0].end_offset, self.notes);
				[delta, idx, prevdelta, previdx].debug("delta, idx, prevdelta, previdx");
				self.notes[0].dur = self.notes[0].start_silence + delta;
				self.vnotes = [self.notes[0]] ++ self.notes[idx..previdx].deepCopy;
				self.vnotes[self.vnotes.lastIndex].dur = self.notes[0].end_silence + prevdelta;
				self.vnotes.debug("sampleline update_note_dur: vnotes");
				self.changed(\notes);
			} {
				if(self.notes.size == 2) {
					self.vnotes = self.notes.deepCopy;
					if( (self.notes[0].start_silence + self.notes[0].end_silence) < 0.01 ) {
						"Protection anti infinite loop: setting end_silence to 0.5".error;
						self.notes[0].end_silence = 0.5
					};
					self.vnotes[0].dur = self.notes[0].start_silence;
					self.vnotes[self.vnotes.lastIndex].dur = self.notes[0].end_silence;
					self.vnotes.debug("sampleline update_note_dur: vnotes");
					self.changed(\notes);
				}
			}
					
		},

		set_start_offset: { arg self, val;
			var dur;
			if(self.notes.size > 2 ) {
				dur = self.total_dur( self.notes[1..(self.notes.lastIndex-1)] );
				if( val >= 0 && (val < (dur - self.notes[0].end_offset)) ) {
					[val, dur, self.notes[0].end_offset, dur - self.notes[0].end_offset].debug("set start_offset: val, dur, eo, dur-eo");
					self.notes[0].start_offset = val;
					self.update_note_dur;
				} {
					[val, dur, self.notes[0].end_offset, dur - self.notes[0].end_offset].debug("can't set start_offset: val, dur, eo, dur-eo");
				}
			} {
				"You are stupid!".debug;
			}
		},

		set_end_offset: { arg self, val;
			var dur;
			if(self.notes.size > 0) {
				dur = self.total_dur( self.notes[1..(self.notes.lastIndex-1)] );
				if( val >= 0 && (val < (dur - self.notes[0].start_offset)) ) {
					[val, dur, self.notes[0].end_offset, dur - self.notes[0].end_offset].debug("can't set end_offset: val, dur, so, dur-so");
					self.notes[0].end_offset = val;
					self.update_note_dur;
				} {
					[val, dur, self.notes[0].start_offset, dur - self.notes[0].start_offset].debug("can't set end_offset: val, dur, so, dur-so");
				}
			}
		},

		get_start_offset: { arg self;
			if(self.notes.size > 0) {
				self.notes[0].start_offset;
			}
		},

		get_end_offset: { arg self;
			if(self.notes.size > 0) {
				self.notes[0].end_offset;
			}
		},

		set_start_silence: { arg self, val;

			if(self.notes.size > 0 && (val >= 0)) {
				self.notes[0].start_silence = val;
				self.update_note_dur;
			} {
				[val, self.notes.size].debug("can't set start_silence: val, notessize");
			}
		},

		set_end_silence: { arg self, val;

			if(self.notes.size > 0 && (val >= 0)) {
				self.notes[0].end_silence = val;
				self.update_note_dur;
			} {
				[val, self.notes.size].debug("can't set end_silence: val, notessize");

			};
		},

		get_start_silence: { arg self;
			if(self.notes.size > 0) {
				self.notes[0].start_silence;
			}

		},

		get_end_silence: { arg self;
			if(self.notes.size > 0) {
				self.notes[0].end_silence;
			}

		},

		set_first_note_dur: { arg self, val;
			var res = 0, lastdur = 0, vidx = 0;
			if( self.notes.size > 0) {
				self.notes[0].dur = val;
				if( val < 0 ) {
					self.notes.do { arg x;
						if( res < val.neg ) {
							res = x.dur + res;
							vidx = vidx + 1;
							lastdur = x.dur;
						}
					};
					self.notes[0].virtual_start_idx = vidx -1;
					self.notes[0].virtual_start_dur = res - val.neg;
				}
			}
		},

		get_first_note_dur: { arg self;
			self.notes.size.debug("get_first_note_dur self.notes.size");
			if( self.notes.size > 0) {
				self.notes[0].dur;
			} {
				nil
			}
		},

		set_notequant: { arg self, val;
			self.notequant = val;
			self.changed(\notes);
		},

		tick: { arg idx; 
			"£££££££££££££££££££££££££££££££££££££TICK"
			//"TICK!".postln;
		},

		mute: { arg self, val;
			self.muted = val;
		},

		toggle_cell: { arg self, idx;
			var oldsel;
			[idx, self.get_cells].debug("make_control_param.select_cell idx, selg.get_cells");
			if( idx < self.get_cells.size, {
				//oldsel = self.selected_cell;
				self.selected_cell = idx;
				//self.changed(\selected_cell, oldsel);
				self.seq.val[ idx ] = ~toggle_value.(self.seq.val[ idx ]);
				self.changed(\val, self.selected_cell);
			})
		},
		refresh: { arg self;
			self.update_note_dur;
			self.get_notes.debug("noteline param refresh: get_notes");
			self.changed(\notes);
			self.changed(\selected);
		},
		vpattern: { arg self; 
			//"YE SOUI PREMIER!!!!".debug;
			"--------making vpattern of sampleline".debug;
			~pdynarray.( { arg idx;
				self.tick; 
				[idx, self.get_note(idx)].debug("4444444444444444444444444444444444444 sampleline vpattern: note");
				self.get_note(idx);
			}, \sampleline );
			//self.get_note(0);
		};

	);
	ret;
};
